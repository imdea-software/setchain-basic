package types

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"crypto/sha256"
	"encoding/binary"
	"fmt"
)

type RBBCRound uint64

type ProposerIndex uint32

type ProposerPublicKey ed25519.PublicKey

type ProposerSecretKey ed25519.PrivateKey

type ProposerSignature []byte

type Proposer struct {
	Index ProposerIndex
	PK    ProposerPublicKey
}

type ProposerIdentity struct {
	Index ProposerIndex
	PK    ProposerPublicKey
	SK    ProposerSecretKey
}

func NewProposerIdentity(pi ProposerIndex) (*ProposerIdentity, error) {
	pk, sk, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, err
	}
	return &ProposerIdentity{
		Index: pi,
		PK:    ProposerPublicKey(pk),
		SK:    ProposerSecretKey(sk),
	}, nil
}

func (pi *ProposerIdentity) GetProposer() *Proposer {
	return &Proposer{
		Index: pi.Index,
		PK:    pi.PK,
	}
}

type Transaction []byte

type TransactionIndex uint32

func (t Transaction) Hash() Hash {
	return sha256.Sum256(t)
}

//Given a transaction t and a secret key sk returns a new transaction [pk,sig,t] where
//pk is the public key corresponding to sk,
//sig is the signature generated by signing t with sk.
func (t Transaction) Sign(sk ed25519.PrivateKey) Transaction {
	sig := ed25519.Sign(sk, t)
	pk := sk.Public()

	buf := bytes.Buffer{}
	binary.Write(&buf, binary.BigEndian, pk)
	binary.Write(&buf, binary.BigEndian, sig)
	binary.Write(&buf, binary.BigEndian, t)

	return buf.Bytes()
}

//Given a transaction of the form [pk,sig,tx] reports whether sig is a valid signature of t by pk
//Assumes pk has length 32 and sig has length 64.
func VerifySignedTransaction(t Transaction) bool {
	pk := []byte(t[:32])
	sig := t[32:96]
	tx := t[96:]
	return ed25519.Verify(pk, tx, sig)
}

// Clean in-place the given transaction list from given indexes
func PurgeTxList(txs []Transaction, txis []TransactionIndex) []Transaction {
	for _, index := range txis {
		txs[index] = nil
	}
	for i := 0; i < len(txs); i++ {
		if txs[i] == nil {
			for j := i + 1; j < len(txs) && txs[i] == nil; j++ {
				txs[i] = txs[j]
			}
		}
	}
	return txs[:len(txs)-len(txis)]
}

type Proposal struct {
	Txs       []Transaction
	Proposer  *Proposer
	Round     RBBCRound
	Hash      Hash
	Signature ProposerSignature
}

func NewProposal(txs []Transaction, pi *ProposerIdentity, r RBBCRound) *Proposal {
	buf := bytes.Buffer{}
	for _, tx := range txs {
		buf.Write(tx)
	}
	p := &Proposal{
		Txs:      txs,
		Proposer: pi.GetProposer(),
		Round:    r,
	}
	binary.Write(&buf, binary.BigEndian, p.Proposer.Index)
	binary.Write(&buf, binary.BigEndian, p.Proposer.PK)
	binary.Write(&buf, binary.BigEndian, r)
	p.Hash = sha256.Sum256(buf.Bytes())
	p.Signature = ed25519.Sign(ed25519.PrivateKey(pi.SK), p.Hash[:])
	return p
}

func (p *Proposal) Verify() bool {
	buf := bytes.Buffer{}
	for _, tx := range p.Txs {
		buf.Write(tx)
	}
	binary.Write(&buf, binary.BigEndian, p.Proposer.Index)
	binary.Write(&buf, binary.BigEndian, p.Proposer.PK)
	binary.Write(&buf, binary.BigEndian, p.Round)
	hash := sha256.Sum256(buf.Bytes())
	if hash != p.Hash {
		return false
	}
	return ed25519.Verify(ed25519.PublicKey(p.Proposer.PK), hash[:], p.Signature)
}

func (p *Proposal) GetIdentifier() *ProposalIdentifier {
	return NewProposalIdentifier(p.Proposer.Index, p.Round)
}

type ProposalIdentifier struct {
	ProposerIndex ProposerIndex
	Round         RBBCRound
}

func NewProposalIdentifier(pi ProposerIndex, r RBBCRound) *ProposalIdentifier {
	return &ProposalIdentifier{
		ProposerIndex: pi,
		Round:         r,
	}
}

type Block struct {
	R   RBBCRound
	Txs TransactionSet
}

func NewBlock(r RBBCRound) *Block {
	return &Block{
		R:   r,
		Txs: TransactionSet{},
	}
}

func (b *Block) IsEqual(b2 *Block) bool {
	if b.R != b2.R {
		return false
	}
	return b.Txs.IsEqual(b2.Txs)
}

func (b *Block) String() string {
	str := fmt.Sprintf("Round: %d\n", b.R)
	for tx := range b.Txs {
		str += fmt.Sprintln(tx)
	}
	return str
}

func (b *Block) Size() uint {
	size := 0
	for tx := range b.Txs {
		size += len(tx)
	}
	return uint(size)
}

type VerifyTransaction func(tx Transaction) bool

type ServerBehaviour uint8

const (
	Correct ServerBehaviour = iota
	Silent                  //Only responds to ping
)
